US-05 - Checkout y confirmación de pedido

[Pega aquí el Prompt Base]

Resumen técnico breve
- Sistema: Craft & Beer (FastAPI + MongoDB)
- Historia: US-05 permitir a usuarios completar el checkout y crear un pedido
- Endpoint: POST /api/pedidos (requiere autenticación)
- Input: datos de envío (dirección_entrega) y método de pago
- Output: creación de pedido con pedido_id, estado, total, fecha_estimada, url_pago (si aplica)
Contrato API (lenguaje claro y técnico)

Escenario: Checkout exitoso con datos de envío y pago

Gherkin (resumen)
- Dado que el usuario está autenticado y tiene un carrito con items válidos
- Y que los items tienen stock suficiente
- Cuando el cliente envía POST /api/pedidos con body que contiene dirección_entrega y metodo_pago
- Entonces el servidor crea el pedido, reserva stock, inicia el proceso de pago (si aplica) y devuelve 201 con detalles del pedido

Endpoint
- URL: /api/pedidos
- Método: POST
- Headers:
  - Authorization: Bearer <token> (obligatorio)
  - Content-Type: application/json

Body request (JSON)
- Esquema:
  {
    "direccion_entrega": {
      "nombre": "string",
      "direccion": "string",
      "ciudad": "string",
      "telefono": "string"
    },
    "metodo_pago": "string", // e.g. "card", "paypal", "transfer", "cash_on_delivery"
    "metadata": { /* optional */ }
  }

Validaciones
- dirección_entrega.nombre, direccion, ciudad, telefono: obligatorios, strings no vacíos
- telefono: validar formato mínimo (ej. 8-15 dígitos)
- metodo_pago: valor soportado por el sistema; si no -> 400
- Usuario debe tener carrito no vacío; si vacío -> 400
- Verificar stock para cada item; si insuficiente -> 409 Conflict

Responses
- 201 Created
  - Descripción: pedido creado y confirmado (o pendiente de pago según metodo)
  - Content-Type: application/json
  - Esquema:
    {
      "pedido_id": "string",        // ObjectId u UUID
      "estado": "string",          // e.g. "CREATED", "PENDING_PAYMENT", "PAID", "FAILED"
      "total": 123.45,
      "fecha_estimada": "2025-09-28T15:30:00Z",
      "url_pago": "https://payments.gateway/checkout/abc123" // opcional, si required by payment method
    }

  - Ejemplo (pago por tarjeta, redirección a url_pago):

  HTTP/1.1 201 Created
  Content-Type: application/json

  {
    "pedido_id": "651e4f2c4c3e2a6b9d0f5e77",
    "estado": "PENDING_PAYMENT",
    "total": 58.50,
    "fecha_estimada": "2025-09-28T18:00:00Z",
    "url_pago": "https://payments.craftandbeer.local/checkout/xyz-123"
  }

  - Ejemplo (pago contra entrega):

  HTTP/1.1 201 Created
  Content-Type: application/json

  {
    "pedido_id": "651e4f2c4c3e2a6b9d0f5e78",
    "estado": "CREATED",
    "total": 58.50,
    "fecha_estimada": "2025-09-28T18:00:00Z",
    "url_pago": null
  }

- 400 Bad Request
  - Causa: cuerpo inválido, direccion_entrega faltante, metodo_pago no soportado, carrito vacío
  - Ejemplo:

  HTTP/1.1 400 Bad Request
  Content-Type: application/json

  {
    "error": { "code": 400, "message": "Datos de checkout inválidos", "details": { "field": "direccion_entrega.direccion", "message": "required" } }
  }

- 401 Unauthorized
  - Causa: token ausente o inválido
  - Ejemplo:
    { "error": { "code": 401, "message": "Autenticación requerida" } }

- 409 Conflict
  - Causa: stock insuficiente para uno o más items (reserve/check failed)
  - Esquema:
    {
      "error": {
        "code": 409,
        "message": "Stock insuficiente para algunos items",
        "details": [ { "producto_id": "650c3d2f4c3e2a6b9d0f3c10", "available": 1, "requested": 3 } ]
      }
    }

  - Ejemplo:

  HTTP/1.1 409 Conflict
  Content-Type: application/json

  {
    "error": {
      "code": 409,
      "message": "Stock insuficiente para algunos items",
      "details": [ { "producto_id": "650c3d2f4c3e2a6b9d0f3c10", "available": 1, "requested": 3 } ]
    }
  }

- 402 Payment Required (opcional)
  - Causa: pago rechazado por gateway
  - Ejemplo:
    { "error": { "code": 402, "message": "Pago rechazado", "details": { "reason": "card_declined" } } }

- 500 Internal Server Error
  - Causa: error interno (DB, gateway). Respuesta genérica:
    { "error": { "code": 500, "message": "Error interno del servidor" } }

Notas de implementación
- Flujos de pago:
  - Para métodos externos (card, paypal) -> crear pedido con estado PENDING_PAYMENT, reservar stock temporalmente, crear sesión en gateway y devolver url_pago.
  - Para métodos inmediatos (cash_on_delivery, transfer) -> crear pedido con estado CREATED o PAID según política y decrementar stock inmediatamente.
- Atomicidad: usar transacciones (MongoDB multi-doc transactions) o pattern de reserva+confirmación para evitar overselling.
- Idempotencia: aplicar idempotency-key header opcional para evitar duplicación de pedidos en reintentos del cliente.
- Validación y seguridad: verificar que el carrito pertenece al usuario autenticado; calcular total en servidor y no confiar en valores enviados por cliente.
- Fecha estimada: calcular según zona logística y SLA (ej. 24-48 horas) y devolver en ISO 8601 UTC.

Recomendaciones para tests
- Happy path: pedido creado y url_pago devuelta para métodos que lo requieren
- 409: simular stock insuficiente
- 402: simular rechazo del gateway (si se integra)
- 401: llamada sin token
- Idempotencia: reintento con la misma idempotency-key no debe crear duplicados

Contrato técnico compacto
- Input: POST /api/pedidos with { direccion_entrega, metodo_pago }
- Output: 201 { pedido_id, estado, total, fecha_estimada, url_pago }
- Errors: 400, 401, 402 (optional), 409, 500

Checklist de cumplimiento
- Título con número de historia: presente
- Escenario Gherkin con endpoint, método, parámetros, body request y response: presente
- JSON examples realistas: incluidos
- Códigos HTTP específicos: 201, 400, 401, 402, 409, 500 incluidos
- Lenguaje claro y técnico: cumplido


