US-06 - Registro de nuevo usuario

Contexto
- Sistema: Craft & Beer (FastAPI + MongoDB)
- Propósito: permitir a un usuario crear una cuenta única en la plataforma.

Resumen rápido
- Endpoint: POST /api/usuarios/registro
- Body (JSON): { email, password, nombre }
- Validaciones server-side:
  - email: formato válido, único en colección `usuarios`
  - password: mínimo 8 caracteres, al menos 1 mayúscula y 1 número
  - nombre: no vacío
 - Respuestas: 201 (creado), 409 (conflicto - email existente), 400 (validación)

Regex de política de contraseña
 - ^(?=.*[A-Z])(?=.*\d).{8,}$

Esquemas (técnico)
- Request JSON
  - email: string (email)
  - password: string
  - nombre: string

- Success Response (201 Created)
  - Content-Type: application/json
  - Location: /api/usuarios/{id} (opcional)
  - Body: {
      "id": "string (Mongo ObjectId)",
      "email": "string",
      "nombre": "string",
      "created_at": "ISO-8601 string",
      "token": "string (JWT)" // opcional - si el sistema entrega token al registrarse
    }

- Error Response (400, 409)
  - Content-Type: application/json
  - Body: {
      "error": "short_code",
      "message": "Mensaje técnico y legible",
      "details": { ...optional... }
    }

Escenarios Gherkin y detalles por escenario

1) Registro exitoso
Scenario: Registro exitoso
  Given cuerpo válido con email nuevo, contraseña que cumple la política y nombre
  When POST /api/usuarios/registro
  Then HTTP 201 Created
  And Location: /api/usuarios/{id}
  And Response body JSON con id, email, nombre, created_at y token (si aplica)

Endpoint: /api/usuarios/registro
Method: POST
Headers:
  - Content-Type: application/json
Request body example:
{
  "email": "maria.perez@craftbeer.example",
  "password": "Secreto123",
  "nombre": "María Pérez"
}

Response (201 Created):
{
  "id": "64f1a2b3c4d5e6f7890a1234",
  "email": "maria.perez@craftbeer.example",
  "nombre": "María Pérez",
  "created_at": "2025-09-26T14:32:00Z",
  "token": "eyJhbGciOiJI..."   
}

Notas:
 - Implementación en FastAPI: crear recurso en MongoDB (colección `usuarios`) y devolver 201.
 - Se recomienda almacenar contraseña hasheada (bcrypt/argon2) y nunca devolverla.

2) Email ya registrado (error 409)
Scenario: Email ya registrado
  Given existe un usuario con email "maria.perez@craftbeer.example"
  When se hace POST /api/usuarios/registro con el mismo email
  Then HTTP 409 Conflict
  And Response body JSON con código de error y mensaje claro

Endpoint: /api/usuarios/registro
Method: POST
Headers:
  - Content-Type: application/json
Request body example:
{
  "email": "maria.perez@craftbeer.example",
  "password": "Secreto123",
  "nombre": "María Pérez"
}

Response (409 Conflict):
{
  "error": "email_conflict",
  "message": "El email 'maria.perez@craftbeer.example' ya está registrado.",
  "details": {
    "field": "email"
  }
}

Razonamiento: usar 409 para indicar conflicto de unicidad. Alternativa: 400 con código de validación, pero se pide 409.

3) Contraseña no cumple política (error 400)
Scenario: Contraseña inválida según política
  Given el cuerpo tiene un password que no cumple (ej.: sin mayúscula o menos de 8 char)
  When POST /api/usuarios/registro
  Then HTTP 400 Bad Request
  And Response JSON con errores de validación (campo y mensaje)

Endpoint: /api/usuarios/registro
Method: POST
Headers:
  - Content-Type: application/json
Request body example (fallido):
{
  "email": "nuevo.usuario@craftbeer.example",
  "password": "secreto",   
  "nombre": "Nuevo Usuario"
}

Response (400 Bad Request):
{
  "error": "validation_error",
  "message": "Datos de entrada inválidos",
  "details": {
    "password": "La contraseña debe tener al menos 8 caracteres, incluir 1 mayúscula y 1 número."
  }
}

Notas de implementación (concisas)
- Búsqueda de email: índice único en MongoDB sobre `email` para garantizar atomicidad y evitar race conditions.
- Validación previa: usar pydantic/validators en FastAPI y comprobar regex ^(?=.*[A-Z])(?=.*\d).{8,}$.
- Errores: normalizar esquema de errores para que el cliente pueda parsear `error` y `details`.

Mapa rápido de códigos HTTP usados
- 201 Created: usuario creado correctamente (body con id y metadata)
- 400 Bad Request: fallo de validación de entrada (ej.: contraseña, formato email)
- 409 Conflict: email ya registrado
- 500 Internal Server Error: error no esperado (definir logging)

Fin del contrato (resumido).
